<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Promises</title>
  <link rel="stylesheet" href="../base.css">
</head>
<style>
 *{
   box-sizing: border-box;
   margin: 0;
   padding: 0;
 }
 body{
   background-color: darkblue;
   color: #fff;
   height: 100vh;
   display: grid;
   place-content: center;
   font-size: 1rem;
 }
</style>
<body>
  <div class="myclass"></div>
  <script>
  const el = document.querySelector(".myclass")
  console.log(el)

/**
 * 
 * 
 * const makePizza = (toppings) => {
  const pizzaPromise = new Promise((resolve,reject)=>{
    //wait 5 seconds for the pizza to cook
   setTimeout(() => {resolve(`Here is your pizza ðŸ• with the toppings ${toppings.join(' ')}`);
  },5000);
     //if something went wrong, we can reject this promise
  });
  return pizzaPromise;
}

const pepperoniPromise = makePizza(['pepperoni']);
const canadianPromise = makePizza(['pepperoni','mushroom', 'onion'])

pepperoniPromise.then((pizza)=>{
  console.log('Ah i got it')
  console.log(pizza)
  el.textContent = pizza;
})
***/
// If you refresh the page, you will see in the console that we get our promise immediately and then 5 seconds after we actually have access to our pizza.


// That is a great example of how we sometimes have to wait.

// Often what you will see is instead of making a promise and then returning it, people will often just return the promise immediately.

/**const makePizza = (toppings =[]) => {
  return new Promise((resolve,reject)=>{
    //wait 5 seconds for the pizza to cook
   setTimeout(() => {resolve(`Here is your pizza ðŸ• with the toppings ${toppings.join(' ')}`);
  },5000);
     //if something went wrong, we can reject this promise
  });
}**/

// The logic to how a Promise gets resolved is always inside of the Promise body, which in the example is the code below

/**function(resolve, reject){
    //wait 1 second for the pizza to cook
    setTimeout(function(){
      resolve(`Here is your pizza ðŸ• with the toppings ${toppings.join(' ')}`);
    }, 1000)
    //if something went wrong, we can reject this promise
  }
  **/
  //That function will resolve or reject whenever it feels ready. In our case, we feel like the pizza is ready after one second.

//So what is happening here is when we declare our pepperoniPromise we can call makePizza(['pepperoni']), which returns a promise of pizza. In order to get the pizza, the way we can access the resolved value is by chaining a .then onto it.
/**const pepperoniPromise = makePizza(['pepperoni']);
const canadianPromise = makePizza(['pepperoni','mushroom', 'onions'])

console.log('starting')
pepperoniPromise.then((pizza)=>{
  console.log('Ah i got it')
  console.log(pizza)
  el.textContent = pizza;
})
console.log('finishing')
**/
//We will look at how we can use async/await to actually do that sequentially if we would like to, but for now we know we can chain a .then() onto it.

//Why is that any more useful than a regular callback?

//That is useful because let's say we wanted to make multiple pizzas one after the other, and we have an oven that can only cook one at at time.

// Delete our canadianPizza and pepperoniPizza declaration code and everything below it in the script tag and just leave the line below

// We can chain a .then() immediately onto it (because makePizza returns a promise), which gives a function that has a pizza. LLog the pizza so that we know that it still works.

//The neat thing is if from this then() we return another makePizza, you can then chain another .then() on that function.
/**
makePizza(['pepperoni','ham']).then((pizza) => {
  console.log(pizza)
  return makePizza(['ham','cheese']);
}).then((pizza) => {
    console.log(pizza)
    return makePizza(['hot peppers','onions','feta'])
  }).then((pizza) => {
    console.log(pizza)
    return makePizza(['pineapple'])
  }).then((pizza) => {
    console.log(pizza)
    return makePizza(['one', 'two', 'three', 'four', 'one', 'two', 'three', 'four', 'one', 'two', 'three', 'four']);
  }).then((pizza) => {
    console.log(pizza)
  })
  **/
  // As you can see first we get one pizza and then after a second we see the other pizza logged to the console.


//Unlike what we were doing the lesson where we were adding and removing classes which were all nested in callback hell, this chaining of then is the promise land and it allows us to keep all of our logic one level deep.

//The downside to that is if you had a log of First and After all our promise chaining, both logs would execute before any of our pizzas are logged.
/**
console.log('first')
makePizza(['pepperoni','ham']).then((pizza) => {
  console.log(pizza)
  return makePizza(['ham','cheese']);
}).then((pizza) => {
    console.log(pizza)
    return makePizza(['hot peppers','onions','feta'])
  }).then((pizza) => {
    console.log(pizza)
    return makePizza(['pineapple'])
  }).then((pizza) => {
    console.log(pizza)
    return makePizza(['one', 'two', 'three', 'four', 'one', 'two', 'three', 'four', 'one', 'two', 'three', 'four']);
  }).then((pizza) => {
    console.log(pizza)
  })
  console.log('right after')
**/
// We will look at how we can use async/await to get around that.

// If you look at the call stack, what we know is that it first runs the function makePizza(['pepperoni']) (highlighted in the image below), which immediately returns a promise.

// Then it runs the bottom log, before jumping back up to the first then() we have when the promise is resolved, and then it keeps going down the promise chain.

// Let's make our makePizza function a bit more resilient, starting with toppings.

// Set an empty array as the default because sometimes people might order a pizza with nothing on it.

// function makePizza(toppings = [])


// For every single topping that is added to the pizza, let's add 200 milliseconds to the initial bake time which is 500. Let's calculate that and save it in a variable as shown below ðŸ‘‡

// const amountOfTimeToBake = 500 + (toppings.length * 200);
// Now we will take that variable and pass it to our timeout.

const makePizza = (toppings =[]) => {
  return new Promise((resolve,reject)=>{
    //wait 5 seconds for the pizza to cook
const amountOfTimeToBake = 500 + (toppings.length * 200);
   setTimeout(() => {resolve(`Here is your pizza ðŸ• with the toppings ${toppings.join(' ')}`);
  },amountOfTimeToBake);
     //if something went wrong, we can reject this promise
  });
}


/**console.log('first')
makePizza(['pepperoni','ham']).then((pizza) => {
  console.log(pizza)
  return makePizza(['ham','cheese']);
}).then((pizza) => {
    console.log(pizza)
    return makePizza(['hot peppers','onions','feta'])
  }).then((pizza) => {
    console.log(pizza)
    return makePizza(['pineapple'])
  }).then((pizza) => {
    console.log(pizza)
    return makePizza()
  }).then((pizza) => {
    console.log(pizza)
    return makePizza(['one', 'two', 'three', 'four', 'one', 'two', 'three', 'four', 'one', 'two', 'three', 'four']);
  }).then((pizza) => {
    console.log('All done! here is your last pizza');
      console.log(pizza)
    })
  console.log('right After')
 **/
//When we refresh the page and the above code is executed, what should happen is ham and cheese should be logged to the console faster than the pizza with 3 toppings.

// Let's chain 2 more pizzas together, one with no toppings, the other with a lot of toppings. Then let's resolve that last pizza and just log it using an arrow function as shown above.

//Promise.all()

//Let's say we have a big oven and we can make all the pizzas at once. You could run them all concurrently, instead of one after another like we are doing (which is referred to as sequentially).

//If you have 10 employees and an oven big enough to cook them all at once, you can do it like so ðŸ‘‡

// Run them Concurrently
  const pizzaPromise1 = makePizza(['hot peppers', 'onion', 'feta']);
  const pizzaPromise2 = makePizza(['one', 'two', 'three', 'four', 'one', 'two', 'three', 'four', 'one', 'two', 'three', 'four']);
  const pizzaPromise3 = makePizza(['ham', 'cheese']);

// So how do we know when all of those promises are done? We could do .then() on each of them like so ðŸ‘‡
pizzaPromise1.then(pizza => {
  console.log(pizza)
})
pizzaPromise2.then(pizza => {
  console.log(pizza)
})
pizzaPromise3.then(pizza => {
  console.log(pizza)
})

// But those are going to pop into the console in whatever order they are done, which isn't what we want. We can instead make it into a "mega promise" that we then wait upon.

// If you have a few promises and all you care about is when all 3 of them are finished, you can make a mega promises, which we will call a dinnerPromise.

const dinnerPromise = Promise.all([pizzaPromise1, pizzaPromise2, pizzaPromise3]);

  </script>
</body>

</html>
